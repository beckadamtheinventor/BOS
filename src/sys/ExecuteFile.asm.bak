
;@DOES Execute a file.
;@INPUT int sys_ExecuteFile(const char *path, char *args);
;@OUTPUT -1 and Cf set if file does not exist or is not a valid executable format, or if malloc failed somewhere.
;@OUTPUT ExecutingFileFd set to point to file descriptor. -1 if file not found
;@DESTROYS All, OP6.
;@NOTE If you're running a threaded executable, the thread is spawned but won't actually start until it's thread is handled.
;;;@NOTE If OS threading is enabled, sleep current thread and execute a file in a new thread given a relative or absolute path. Returns to caller if starting a threaded executable.
;@NOTE If OS threading is disabled, execute a file in a new thread given a relative or absolute path. Returns to caller if starting a threaded executable.
sys_ExecuteFile:
	scf
	sbc hl,hl
	ld (ExecutingFileFd),hl
	xor a,a
	ld (return_code_flags),a
	pop bc
	pop hl
	pop de
	push de
	push hl
	push bc
.entryhlde:
	ld a,(hl)
	or a,a
	jq z,.fail
	ld (fsOP6+3),hl
	ld (fsOP6),de
	push hl
	call sys_OpenFileInPath ;look for the file within dirs listed in $PATH
	pop bc
	jq c,.fail ;fail if both fs_OpenFile and sys_OpenFileInPath failed to locate the file
.open_fd:
	ld (ExecutingFileFd),hl
	ld bc,fsentry_fileattr
	add hl,bc
	bit fd_subdir,(hl)
	jq nz,.fail ;can't execute a directory
	sbc hl,bc
	push hl
	call fs_GetFDLen
	ex (sp),hl
	push hl
	call fs_GetFDPtr
	pop bc,bc
	ld (running_program_ptr),hl
.exec_check_loop:
	ld a,(hl)
	inc hl
	cp a,$18 ;jr
	jq z,.skip1
	cp a,$C3 ;jp
	jq z,.skip3
	cp a,'#'
	jq z,.executable_text
	cp a,$EF
	jq nz,.tryvarheader
	ld a,(hl)
	inc hl
	cp a,$7B
	jq z,.exec_rex_entryhl ;jump to execute if $EF,$7B header
	dec hl
.tryvarheader: ; try running it as a ti formatted var file
	dec hl
	ld bc,0
	ld c,(hl)
	add hl,bc
	ld c,(hl)
	inc hl
	ld b,(hl)
	inc hl
	ld a,(hl)
	cp a,$EF
	jq nz,.fail
	inc hl
	ld a,(hl)
	cp a,$7B
	jq nz,.fail
	inc hl
	dec bc
	dec bc
	ld a,c
	or a,b
	jq nz,.exec_copy_to_usermem ; execute if valid header and there is program data to copy
; fail if unrecognized header
.fail:
	scf
	sbc hl,hl
	ret
.skip3:
	inc hl
	inc hl
.skip1:
	inc hl
	; ld a,$7F
	; cp a,(hl)
	; jq nz,.notezf
	; inc hl
	; ld de,(hl)
	; db $21, 'EZF'
	; or a,a
	; sbc hl,de
	; jq nz,.fail
	; ld hl,(ExecutingFileFD)
	; jq sys_ExecuteEZF.loadfromfd
.notezf:
	ld de,(hl)
	db $21, 'TRX' ;ld hl, 'TRX' ;Threaded Ram eXecutable
	or a,a
	sbc hl,de
	jq z,.exec_threaded_rex
	db $21, 'TFX' ;ld hl, 'TFX' ;Threaded Flash eXecutable
	or a,a
	sbc hl,de
	jq z,.exec_threaded_fex
	db $21, 'CRX' ;ld hl, 'CRX' ;Compressed Ram eXecutable
	or a,a
	sbc hl,de
	jq z,.exec_compressed_rex
	db $21, 'FEX' ;ld hl, 'FEX' ;Flash EXecutable
	or a,a
	sbc hl,de
	jq z,.exec_fex
	db $21, 'REX' ;ld hl, 'REX' ;Ram EXecutable
	or a,a
	sbc hl,de
	jq nz,.fail ;if it's neither a Flash Executable nor a Ram Executable, return -1

.exec_rex:
	ld hl,(running_program_ptr)
.exec_rex_entryhl:
	push hl
	ld iy,(ExecutingFileFd)
	ld hl,(iy+fsentry_filelen)
	ex.s hl,de
	push de
	pop bc
	pop hl
.exec_copy_to_usermem:
	ld de,bos_UserMem
	push de ;save jump address
	push bc
	ldir
	pop bc
.exec_setup_usermem_bc:
	ld (asm_prgm_size),bc
	ex hl,de
	ld (top_of_UserMem),hl ;save top of usermem
	ld de,-libload_bottom_ptr
	add hl,de
	ld (remaining_free_RAM),hl
	pop hl  ;usermem
	ld (running_program_ptr),hl
.exec_fex:
	call sys_NextProcessId
	call sys_FreeRunningProcessId ;free memory allocated by the new process ID if there is any
	ld de,(fsOP6) ;arguments string
	call .load_argc_argv_loop
	ld de,(fsOP6)
	ld bc,(fsOP5)
	push de,bc
	; call .normalize_lcd
	; ld a,(threading_enabled)
	; cp a,2
	; jr nz,.runnothreading
	; SleepThread
	; ld bc,(running_program_ptr)
	; ld hl,-12
	; add hl,sp
	; push hl,bc
	; call th_CreateThread.noparent
	; pop bc,bc,bc
	; jq th_HandleNextThread.nosave
	; HandleNextThread ;handle the thread we just spawned
	; jr .ranthread
.runnothreading:
	call .jptoprogram
.ranthread:
	pop bc,bc
	push de,hl
	; call .normalize_lcd
	xor a,a
	sbc hl,hl
	ld (asm_prgm_size),hl
	ld hl,bos_UserMem
	ld (top_of_UserMem),hl
	call sys_FreeRunningProcessId ;free memory allocated by the program
	call sys_PrevProcessId
	pop hl,de
	ret
.exec_compressed_rex:
	ld hl,(running_program_ptr)
	ld a,(hl)
	cp a,$18 ;jr
	jq z,.compressed_rex_skip2
	cp a,$C3 ;jp
	jq nz,.fail
.compressed_rex_skip4:
	inc hl
	inc hl
.compressed_rex_skip2:
	ld bc,6
	add hl,bc ;skip "CRX\0"
	ld de,(hl)
	ld c,4
	add hl,bc ;skip "zx7\0" or whatnot
	ex hl,de
	db $01,"zx7" ;ld bc,...
	or a,a
	sbc hl,bc
	jq nz,.fail ;fail if not zx7 compressed
	ex hl,de
	ld bc,(hl) ;load extracted size
	inc hl
	inc hl
	inc hl
	ld de,bos_UserMem
	push bc,hl,de
	call util_Zx7Decompress
	pop de,hl,bc
	push de
	ex hl,de
	add hl,bc
	ex hl,de
	jq .exec_setup_usermem_bc
.jptoprogram:
	ld hl,(running_program_ptr)
sys_jphl:=$
	jp (hl)
; .normalize_lcd:
	; ld bc,ti.vRam
	; ld (ti.mpLcdUpbase),bc
	; ld a,ti.lcdBpp8
	; ld (ti.mpLcdCtrl),a
	; xor a,a
	; ld (curcol),a
	; ret

.exec_threaded_rex:
	ld hl,(running_program_ptr)
	ld a,(hl)
	cp a,$18
	jq z,.threaded_rex_skipjr
	inc hl
	inc hl
.threaded_rex_skipjr:
	ld de,7 ; length of short jump + length of magic number + length of stack frame chunks indicator
	add hl,de
	ld e,(hl) ; get size of space needed for program
	inc hl
	ld d,(hl)
	inc hl
	push hl,de
	ld a,(running_process_id)
	ld (fsOP6+13),a
	call sys_NextProcessId
	call sys_Malloc
	pop bc
	ex (sp),hl
	push bc
	ld c,(hl) ; get number of entries in relocations table
	inc hl
	ld b,(hl)
	inc hl
	ld (fsOP6+3),hl
	ld (fsOP6+6),bc
	add hl,bc
	add hl,bc ;each entry is 2 bytes. hl should now point to code needing relocation
	pop bc,de
	ld (fsOP6+9),de
	ldir
	ld bc,(fsOP6+6)
	ld a,b
	or a,c
	jq z,.no_relocations
	push iy
	ld iy,(fsOP6+3)
.relocations_loop:
	push bc
	ld c,(iy)
	ld b,(iy+1)
	lea iy,iy+2
	ld hl,(fsOP6+9)
	add hl,bc
	ld bc,(hl)
	ex hl,de
	ld hl,(fsOP6+9)
	add hl,bc
	ex hl,de
	ld (hl),de
	pop bc
	dec bc
	ld a,c
	or a,b
	jq nz,.relocations_loop
	pop iy
.no_relocations:
	ld hl,(running_program_ptr)
	ld de,(fsOP6+9)
	ld (running_program_ptr),de
	jq .exec_threaded_hl
.exec_threaded_fex:
	ld a,(running_process_id)
	ld (fsOP6+13),a
	ld a,1
	ld (running_process_id),a
	ld hl,(running_program_ptr)
.exec_threaded_hl:
	ld a,(hl)
	cp a,$18 ;jr
	jq z,.threaded_skipjr
	inc hl
	inc hl
.threaded_skipjr:
	ld de,6 ;length of short jump + length of magic number
	add hl,de
	ld l,(hl) ;the byte following the magic number should indicate how many 32-byte chunks of stack frame the program requires, minus 1.
	ld h,32
	ld e,h
	mlt hl
	add hl,de ;chunks * 32 + 32
	push hl
	call sys_Malloc
	pop bc
	ret c ;return if failed to malloc

	add hl,bc ;malloc'd pointer for the stack + length because it grows downwards
	ld de,(running_program_ptr)
	push hl,de
	call th_CreateThread ; queue the thread to be run on the next thread switch
	ld a,(fsOP6+13)
	ld (running_process_id),a
	ld hl,return_code_flags
	set bSilentReturn,(hl) ;return to caller silently
	pop hl,de
	ret

.executable_text:
	ld a,(hl)
	inc hl
	cp a,'!'
	jq nz,.fail ; fail if unrecognized executable text format
	ld (fsOP6+6),sp
	push hl ; executable to execute file with
	call fs_PathLen
	inc de
	push de ; de = pre-arguments
	call fs_PathLen.entryde
	push hl ; hl = length of pre-arguments
	ld hl,(fsOP6+3) ; hl = file name
	push hl
	call ti._strlen
	pop bc,de ; bc = file name, de = length of pre-arguments
	push de,bc ; file name
	add hl,de ; length of pre-arguments + file name
	inc hl
	inc hl ; length of pre-arguments + separator + file name + null terminator
	push hl
	call sys_Malloc ; malloc space for the arguments string
	pop bc
	jr c,.executable_text_fail
	ex hl,de
	ld (fsOP6+9),de ; save malloc'd memory pointer
	pop hl ; hl = file name
	pop bc ; bc = length of pre-arguments 
	ex (sp),hl ; hl = pre-arguments
	ldir ; copy pre-arguments
	ld a,' '
	ld (de),a ; add separator
	push de
	call ti._strcpy ; copy the file name string
	pop bc,bc
	ld de,(fsOP6+9) ; arguments string
	pop hl ; program to run this with
	jp .entryhlde

.executable_text_fail:
	ld sp,(fsOP6+6)
	scf
	sbc hl,hl
	ret

; input de = string
.load_argc_argv_loop:
	ld	bc,1
	ld	a,(de)
	or	a,a
	jr	z,.doneargv
	jr	.argvappend
.argvloop:	; loop over argument string
	inc de
	ld	a,(de)
	or	a,a
	jr	z,.doneargv
	cp	a,' '
	jr	nz,.argvloop
	xor	a,a
	ld	(de),a
.argvspacesloop:
	inc	de
	ld	a,(de)
	cp	a,' '
	jr	z,.argvspacesloop
	or	a,a
	jr	z,.doneargv
.argvappend:
	inc	bc
	push	de
	jr	.argvloop
.doneargv:
	sbc hl,hl
	add hl,bc
	add hl,bc
	add hl,bc
	push bc,hl
	call sys_Malloc
	push hl
	ld	hl,(ExecutingFileFd)
	push	hl
	call	fs_CopyFileName	; get file name from running file descriptor
	ex hl,de
	pop	bc
	pop hl ; char *argv[]
	ld (fsOP6),hl
	pop bc ; argc*3
	add hl,bc
	pop bc	; int argc
	ld (fsOP5),bc
	ld (fsOP5+3),de
	dec bc
	ld a,c
	or a,b
	jr z,.argv_no_args
.argv_copy_loop:
	pop de
	dec hl
	dec hl
	dec hl
	ld (hl),de
	dec bc
	ld a,c
	or a,b
	jq nz,.argv_copy_loop
.argv_no_args:
	ld de,(fsOP5+3)
	dec hl
	dec hl
	dec hl
	ld (hl),de
	ret




