<html><head><title>bos.inc docs</title>	<link rel="stylesheet" type="text/css" href="style.css"></head>	<body>	<h1>"bos.inc" documentation</h1>	<b>"bos.DONOTHING" is a no-op and does nothing,</b><br>As the name implies.	<table><th>syscall name</th><th>syscall adress</th>	<tr><td><a href="#boot_os                  ">bos.boot_os                  </a></td><td><a href="#boot_os                  ">020108</a></td></tr>
<tr><td><a href="#handle_interrupt">bos.handle_interrupt</a></td><td><a href="#handle_interrupt">02010C</a></td></tr>
<tr><td><a href="#HandleInstruction        ">bos.HandleInstruction        </a></td><td><a href="#HandleInstruction        ">020110</a></td></tr>
<tr><td><a href="#sc_HandleSysCall         ">bos.sc_HandleSysCall         </a></td><td><a href="#sc_HandleSysCall         ">020114</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING                ">bos.DONOTHING                </a></td><td><a href="#DONOTHING                ">020118</a></td></tr>
<tr><td><a href="#handle_offsetinstruction ">bos.handle_offsetinstruction </a></td><td><a href="#handle_offsetinstruction ">02011C</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING ">bos.DONOTHING </a></td><td><a href="#DONOTHING ">020120</a></td></tr>
<tr><td><a href="#sys_ExecuteFile">bos.sys_ExecuteFile</a></td><td><a href="#sys_ExecuteFile">022400</a></td></tr>
<tr><td><a href="#os_GetOSInfo">bos.os_GetOSInfo</a></td><td><a href="#os_GetOSInfo">022404</a></td></tr>
<tr><td><a href="#fs_OpenFile">bos.fs_OpenFile</a></td><td><a href="#fs_OpenFile">022408</a></td></tr>
<tr><td><a href="#fs_GetSectorAddress">bos.fs_GetSectorAddress</a></td><td><a href="#fs_GetSectorAddress">02240C</a></td></tr>
<tr><td><a href="#fs_CheckDirExists">bos.fs_CheckDirExists</a></td><td><a href="#fs_CheckDirExists">022410</a></td></tr>
<tr><td><a href="#fs_CeilDivBySector">bos.fs_CeilDivBySector</a></td><td><a href="#fs_CeilDivBySector">022414</a></td></tr>
<tr><td><a href="#fs_CopyFileName">bos.fs_CopyFileName</a></td><td><a href="#fs_CopyFileName">022418</a></td></tr>
<tr><td><a href="#fs_Read">bos.fs_Read</a></td><td><a href="#fs_Read">02241C</a></td></tr>
<tr><td><a href="#fs_Write">bos.fs_Write</a></td><td><a href="#fs_Write">022420</a></td></tr>
<tr><td><a href="#sys_AddHLAndA">bos.sys_AddHLAndA</a></td><td><a href="#sys_AddHLAndA">022424</a></td></tr>
<tr><td><a href="#sys_AnyKey">bos.sys_AnyKey</a></td><td><a href="#sys_AnyKey">022428</a></td></tr>
<tr><td><a href="#sys_FreeAll">bos.sys_FreeAll</a></td><td><a href="#sys_FreeAll">02242C</a></td></tr>
<tr><td><a href="#sys_GetKey">bos.sys_GetKey</a></td><td><a href="#sys_GetKey">022430</a></td></tr>
<tr><td><a href="#sys_KbScan">bos.sys_KbScan</a></td><td><a href="#sys_KbScan">022434</a></td></tr>
<tr><td><a href="#sys_Malloc">bos.sys_Malloc</a></td><td><a href="#sys_Malloc">022438</a></td></tr>
<tr><td><a href="#fs_CreateRamFile">bos.fs_CreateRamFile</a></td><td><a href="#fs_CreateRamFile">02243C</a></td></tr>
<tr><td><a href="#sys_MemSet">bos.sys_MemSet</a></td><td><a href="#sys_MemSet">022440</a></td></tr>
<tr><td><a href="#fs_AllocRam">bos.fs_AllocRam</a></td><td><a href="#fs_AllocRam">022444</a></td></tr>
<tr><td><a href="#sys_WaitKey">bos.sys_WaitKey</a></td><td><a href="#sys_WaitKey">022448</a></td></tr>
<tr><td><a href="#sys_WaitKeyCycle">bos.sys_WaitKeyCycle</a></td><td><a href="#sys_WaitKeyCycle">02244C</a></td></tr>
<tr><td><a href="#gui_DrawConsoleWindow">bos.gui_DrawConsoleWindow</a></td><td><a href="#gui_DrawConsoleWindow">022450</a></td></tr>
<tr><td><a href="#gui_Input">bos.gui_Input</a></td><td><a href="#gui_Input">022454</a></td></tr>
<tr><td><a href="#gui_NewLine">bos.gui_NewLine</a></td><td><a href="#gui_NewLine">022458</a></td></tr>
<tr><td><a href="#gui_Print">bos.gui_Print</a></td><td><a href="#gui_Print">02245C</a></td></tr>
<tr><td><a href="#gui_PrintInt">bos.gui_PrintInt</a></td><td><a href="#gui_PrintInt">022460</a></td></tr>
<tr><td><a href="#gui_Scroll">bos.gui_Scroll</a></td><td><a href="#gui_Scroll">022464</a></td></tr>
<tr><td><a href="#gfx_BlitBuffer">bos.gfx_BlitBuffer</a></td><td><a href="#gfx_BlitBuffer">022468</a></td></tr>
<tr><td><a href="#gfx_PrintString">bos.gfx_PrintString</a></td><td><a href="#gfx_PrintString">02246C</a></td></tr>
<tr><td><a href="#_MemClear">bos._MemClear</a></td><td><a href="#_MemClear">022470</a></td></tr>
<tr><td><a href="#_PushOP1">bos._PushOP1</a></td><td><a href="#_PushOP1">022474</a></td></tr>
<tr><td><a href="#_PopOP1">bos._PopOP1</a></td><td><a href="#_PopOP1">022478</a></td></tr>
<tr><td><a href="#_Mov9ToOP1">bos._Mov9ToOP1</a></td><td><a href="#_Mov9ToOP1">02247C</a></td></tr>
<tr><td><a href="#_CpHLDE">bos._CpHLDE</a></td><td><a href="#_CpHLDE">022480</a></td></tr>
<tr><td><a href="#_Mov8b">bos._Mov8b</a></td><td><a href="#_Mov8b">022484</a></td></tr>
<tr><td><a href="#_ChkFindSym">bos._ChkFindSym</a></td><td><a href="#_ChkFindSym">022488</a></td></tr>
<tr><td><a href="#_LoadDEInd_s">bos._LoadDEInd_s</a></td><td><a href="#_LoadDEInd_s">02248C</a></td></tr>
<tr><td><a href="#_EnoughMem">bos._EnoughMem</a></td><td><a href="#_EnoughMem">022490</a></td></tr>
<tr><td><a href="#_InsertMem">bos._InsertMem</a></td><td><a href="#_InsertMem">022494</a></td></tr>
<tr><td><a href="#_SetHLUTo0">bos._SetHLUTo0</a></td><td><a href="#_SetHLUTo0">022498</a></td></tr>
<tr><td><a href="#_PutS">bos._PutS</a></td><td><a href="#_PutS">02249C</a></td></tr>
<tr><td><a href="#_GetCSC">bos._GetCSC</a></td><td><a href="#_GetCSC">0224A0</a></td></tr>
<tr><td><a href="#_NewLine">bos._NewLine</a></td><td><a href="#_NewLine">0224A4</a></td></tr>
<tr><td><a href="#_ClrScrn">bos._ClrScrn</a></td><td><a href="#_ClrScrn">0224A8</a></td></tr>
<tr><td><a href="#_HomeUp">bos._HomeUp</a></td><td><a href="#_HomeUp">0224AC</a></td></tr>
<tr><td><a href="#_ErrMemory">bos._ErrMemory</a></td><td><a href="#_ErrMemory">0224B0</a></td></tr>
<tr><td><a href="#_DrawStatusBar">bos._DrawStatusBar</a></td><td><a href="#_DrawStatusBar">0224B4</a></td></tr>
<tr><td><a href="#_os_GetSystemInfo">bos._os_GetSystemInfo</a></td><td><a href="#_os_GetSystemInfo">0224B8</a></td></tr>
<tr><td><a href="#_UsbPowerVbus">bos._UsbPowerVbus</a></td><td><a href="#_UsbPowerVbus">0224BC</a></td></tr>
<tr><td><a href="#_UsbUnpowerVbus">bos._UsbUnpowerVbus</a></td><td><a href="#_UsbUnpowerVbus">0224C0</a></td></tr>
<tr><td><a href="#sys_EraseFlashSector">bos.sys_EraseFlashSector</a></td><td><a href="#sys_EraseFlashSector">0224C4</a></td></tr>
<tr><td><a href="#sys_FlashUnlock">bos.sys_FlashUnlock</a></td><td><a href="#sys_FlashUnlock">0224C8</a></td></tr>
<tr><td><a href="#sys_FlashLock">bos.sys_FlashLock</a></td><td><a href="#sys_FlashLock">0224CC</a></td></tr>
<tr><td><a href="#fs_CreateFile">bos.fs_CreateFile</a></td><td><a href="#fs_CreateFile">0224D0</a></td></tr>
<tr><td><a href="#strupper">bos.strupper</a></td><td><a href="#strupper">0224D4</a></td></tr>
<tr><td><a href="#strlower">bos.strlower</a></td><td><a href="#strlower">0224D8</a></td></tr>
<tr><td><a href="#fs_AbsPath">bos.fs_AbsPath</a></td><td><a href="#fs_AbsPath">0224DC</a></td></tr>
<tr><td><a href="#fs_MultByBytesPerSector">bos.fs_MultByBytesPerSector</a></td><td><a href="#fs_MultByBytesPerSector">0224E0</a></td></tr>
<tr><td><a href="#_LoadLibraryOP1">bos._LoadLibraryOP1</a></td><td><a href="#_LoadLibraryOP1">0224E4</a></td></tr>
<tr><td><a href="#fs_OpenFileInDir">bos.fs_OpenFileInDir</a></td><td><a href="#fs_OpenFileInDir">0224E8</a></td></tr>
<tr><td><a href="#fs_SetSize">bos.fs_SetSize</a></td><td><a href="#fs_SetSize">0224EC</a></td></tr>
<tr><td><a href="#fs_WriteFile">bos.fs_WriteFile</a></td><td><a href="#fs_WriteFile">0224F0</a></td></tr>
<tr><td><a href="#sys_HLToString">bos.sys_HLToString</a></td><td><a href="#sys_HLToString">0224F4</a></td></tr>
<tr><td><a href="#fs_DeleteFile">bos.fs_DeleteFile</a></td><td><a href="#fs_DeleteFile">0224F8</a></td></tr>
<tr><td><a href="#_DelVar">bos._DelVar</a></td><td><a href="#_DelVar">0224FC</a></td></tr>
<tr><td><a href="#_CreateVar">bos._CreateVar</a></td><td><a href="#_CreateVar">022500</a></td></tr>
<tr><td><a href="#gui_InputNoClear">bos.gui_InputNoClear</a></td><td><a href="#gui_InputNoClear">022504</a></td></tr>
<tr><td><a href="#fs_InitClusterMap">bos.fs_InitClusterMap</a></td><td><a href="#fs_InitClusterMap">022508</a></td></tr>
<tr><td><a href="#sys_WriteFlash">bos.sys_WriteFlash</a></td><td><a href="#sys_WriteFlash">02250C</a></td></tr>
<tr><td><a href="#sys_WriteFlashA">bos.sys_WriteFlashA</a></td><td><a href="#sys_WriteFlashA">022510</a></td></tr>
<tr><td><a href="#sys_JoinArgv">bos.sys_JoinArgv</a></td><td><a href="#sys_JoinArgv">022514</a></td></tr>
<tr><td><a href="#fs_PathLen">bos.fs_PathLen</a></td><td><a href="#fs_PathLen">022518</a></td></tr>
<tr><td><a href="#fs_ParentDir">bos.fs_ParentDir</a></td><td><a href="#fs_ParentDir">02251C</a></td></tr>
<tr><td><a href="#fs_StrToFileEntry">bos.fs_StrToFileEntry</a></td><td><a href="#fs_StrToFileEntry">022520</a></td></tr>
<tr><td><a href="#fs_DirList">bos.fs_DirList</a></td><td><a href="#fs_DirList">022524</a></td></tr>
<tr><td><a href="#sys_Free">bos.sys_Free</a></td><td><a href="#sys_Free">022528</a></td></tr>
<tr><td><a href="#sys_CallExecuteFile">bos.sys_CallExecuteFile</a></td><td><a href="#sys_CallExecuteFile">02252C</a></td></tr>
<tr><td><a href="#sys_JumpExecuteFile">bos.sys_JumpExecuteFile</a></td><td><a href="#sys_JumpExecuteFile">022530</a></td></tr>
<tr><td><a href="#sys_OpenDevice">bos.sys_OpenDevice</a></td><td><a href="#sys_OpenDevice">022534</a></td></tr>
<tr><td><a href="#fs_CopyFile">bos.fs_CopyFile</a></td><td><a href="#fs_CopyFile">022538</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING">bos.DONOTHING</a></td><td><a href="#DONOTHING">02253C</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING">bos.DONOTHING</a></td><td><a href="#DONOTHING">022540</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING">bos.DONOTHING</a></td><td><a href="#DONOTHING">022544</a></td></tr>
<tr><td><a href="#fs_GetSector">bos.fs_GetSector</a></td><td><a href="#fs_GetSector">022548</a></td></tr>
<tr><td><a href="#fs_WriteByte">bos.fs_WriteByte</a></td><td><a href="#fs_WriteByte">02254C</a></td></tr>
<tr><td><a href="#fs_RenameFile">bos.fs_RenameFile</a></td><td><a href="#fs_RenameFile">022550</a></td></tr>
<tr><td><a href="#_SetCursorPos">bos._SetCursorPos</a></td><td><a href="#_SetCursorPos">022554</a></td></tr>
<tr><td><a href="#fs_CreateDir">bos.fs_CreateDir</a></td><td><a href="#fs_CreateDir">022558</a></td></tr>
<tr><td><a href="#gfx_BufClear">bos.gfx_BufClear</a></td><td><a href="#gfx_BufClear">02255C</a></td></tr>
<tr><td><a href="#gfx_LcdClear">bos.gfx_LcdClear</a></td><td><a href="#gfx_LcdClear">022560</a></td></tr>
<tr><td><a href="#fs_SanityCheck">bos.fs_SanityCheck</a></td><td><a href="#fs_SanityCheck">022564</a></td></tr>
<tr><td><a href="#sys_SetOnInterruptHandler">bos.sys_SetOnInterruptHandler</a></td><td><a href="#sys_SetOnInterruptHandler">022568</a></td></tr>
<tr><td><a href="#gui_PrintChar">bos.gui_PrintChar</a></td><td><a href="#gui_PrintChar">02256C</a></td></tr>
<tr><td><a href="#gfx_SetDraw">bos.gfx_SetDraw</a></td><td><a href="#gfx_SetDraw">022570</a></td></tr>
<tr><td><a href="#gui_PrintString">bos.gui_PrintString</a></td><td><a href="#gui_PrintString">022574</a></td></tr>
<tr><td><a href="#gui_PrintLine">bos.gui_PrintLine</a></td><td><a href="#gui_PrintLine">022578</a></td></tr>
<tr><td><a href="#gui_PrintUInt">bos.gui_PrintUInt</a></td><td><a href="#gui_PrintUInt">02257C</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING ">bos.DONOTHING </a></td><td><a href="#DONOTHING ">022580</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING ">bos.DONOTHING </a></td><td><a href="#DONOTHING ">022584</a></td></tr>
<tr><td><a href="#fs_GetFilePtrRaw">bos.fs_GetFilePtrRaw</a></td><td><a href="#fs_GetFilePtrRaw">022588</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING ">bos.DONOTHING </a></td><td><a href="#DONOTHING ">02258C</a></td></tr>
<tr><td><a href="#sys_ExecuteFileHL">bos.sys_ExecuteFileHL</a></td><td><a href="#sys_ExecuteFileHL">022590</a></td></tr>
<tr><td><a href="#sys_TurnOff">bos.sys_TurnOff</a></td><td><a href="#sys_TurnOff">022594</a></td></tr>
<tr><td><a href="#sys_NextProcessId">bos.sys_NextProcessId</a></td><td><a href="#sys_NextProcessId">022598</a></td></tr>
<tr><td><a href="#sys_PrevProcessId">bos.sys_PrevProcessId</a></td><td><a href="#sys_PrevProcessId">02259C</a></td></tr>
<tr><td><a href="#sys_FreeProcessId">bos.sys_FreeProcessId</a></td><td><a href="#sys_FreeProcessId">0225A0</a></td></tr>
<tr><td><a href="#fs_GarbageCollect">bos.fs_GarbageCollect</a></td><td><a href="#fs_GarbageCollect">0225A4</a></td></tr>
<tr><td><a href="#gfx_SwapTextColors">bos.gfx_SwapTextColors</a></td><td><a href="#gfx_SwapTextColors">0225A8</a></td></tr>
<tr><td><a href="#fs_WriteNewFile">bos.fs_WriteNewFile</a></td><td><a href="#fs_WriteNewFile">0225AC</a></td></tr>
<tr><td><a href="#gfx_SetFont">bos.gfx_SetFont</a></td><td><a href="#gfx_SetFont">0225B0</a></td></tr>
<tr><td><a href="#gfx_SetDefaultFont">bos.gfx_SetDefaultFont</a></td><td><a href="#gfx_SetDefaultFont">0225B4</a></td></tr>
<tr><td><a href="#sys_FreeRunningProcessId">bos.sys_FreeRunningProcessId</a></td><td><a href="#sys_FreeRunningProcessId">0225B8</a></td></tr>
<tr><td><a href="#util_Zx7Decompress">bos.util_Zx7Decompress</a></td><td><a href="#util_Zx7Decompress">0225BC</a></td></tr>
<tr><td><a href="#sys_CheckMallocRAM">bos.sys_CheckMallocRAM</a></td><td><a href="#sys_CheckMallocRAM">0225C0</a></td></tr>
<tr><td><a href="#gfx_Compute">bos.gfx_Compute</a></td><td><a href="#gfx_Compute">0225C4</a></td></tr>
<tr><td><a href="#gfx_FillRectangle">bos.gfx_FillRectangle</a></td><td><a href="#gfx_FillRectangle">0225C8</a></td></tr>
<tr><td><a href="#gfx_FillScreen">bos.gfx_FillScreen</a></td><td><a href="#gfx_FillScreen">0225CC</a></td></tr>
<tr><td><a href="#gfx_GetFontPtr">bos.gfx_GetFontPtr</a></td><td><a href="#gfx_GetFontPtr">0225D0</a></td></tr>
<tr><td><a href="#gfx_HorizLine">bos.gfx_HorizLine</a></td><td><a href="#gfx_HorizLine">0225D4</a></td></tr>
<tr><td><a href="#gfx_InitStdPalette">bos.gfx_InitStdPalette</a></td><td><a href="#gfx_InitStdPalette">0225D8</a></td></tr>
<tr><td><a href="#gfx_NextLine">bos.gfx_NextLine</a></td><td><a href="#gfx_NextLine">0225DC</a></td></tr>
<tr><td><a href="#gfx_PrintChar">bos.gfx_PrintChar</a></td><td><a href="#gfx_PrintChar">0225E0</a></td></tr>
<tr><td><a href="#gfx_PrintHexA">bos.gfx_PrintHexA</a></td><td><a href="#gfx_PrintHexA">0225E4</a></td></tr>
<tr><td><a href="#gfx_PrintUInt">bos.gfx_PrintUInt</a></td><td><a href="#gfx_PrintUInt">0225E8</a></td></tr>
<tr><td><a href="#gfx_Rectangle">bos.gfx_Rectangle</a></td><td><a href="#gfx_Rectangle">0225EC</a></td></tr>
<tr><td><a href="#gfx_Set8bpp">bos.gfx_Set8bpp</a></td><td><a href="#gfx_Set8bpp">0225F0</a></td></tr>
<tr><td><a href="#gfx_Set16bpp">bos.gfx_Set16bpp</a></td><td><a href="#gfx_Set16bpp">0225F4</a></td></tr>
<tr><td><a href="#gfx_SetTextXY">bos.gfx_SetTextXY</a></td><td><a href="#gfx_SetTextXY">0225F8</a></td></tr>
<tr><td><a href="#gfx_Sprite">bos.gfx_Sprite</a></td><td><a href="#gfx_Sprite">0225FC</a></td></tr>
<tr><td><a href="#gfx_Sprite2x">bos.gfx_Sprite2x</a></td><td><a href="#gfx_Sprite2x">022600</a></td></tr>
<tr><td><a href="#gfx_VertLine">bos.gfx_VertLine</a></td><td><a href="#gfx_VertLine">022604</a></td></tr>
<tr><td><a href="#sys_Malloc32Align32">bos.sys_Malloc32Align32</a></td><td><a href="#sys_Malloc32Align32">022608</a></td></tr>
<tr><td><a href="#sys_Malloc64Align256">bos.sys_Malloc64Align256</a></td><td><a href="#sys_Malloc64Align256">02260C</a></td></tr>
<tr><td><a href="#gfx_PrintStringXY">bos.gfx_PrintStringXY</a></td><td><a href="#gfx_PrintStringXY">022610</a></td></tr>
<tr><td><a href="#gfx_GetTextX">bos.gfx_GetTextX</a></td><td><a href="#gfx_GetTextX">022614</a></td></tr>
<tr><td><a href="#gfx_GetTextY">bos.gfx_GetTextY</a></td><td><a href="#gfx_GetTextY">022618</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING ">bos.DONOTHING </a></td><td><a href="#DONOTHING ">02261C</a></td></tr>
<tr class="no_op"></tr><td><a href="#DONOTHING ">bos.DONOTHING </a></td><td><a href="#DONOTHING ">022620</a></td></tr>
<tr><td><a href="#sys_OpenFileInPath">bos.sys_OpenFileInPath</a></td><td><a href="#sys_OpenFileInPath">022624</a></td></tr>
<tr><td><a href="#sys_VarString">bos.sys_VarString</a></td><td><a href="#sys_VarString">022628</a></td></tr>
<tr><td><a href="#fs_GetFreeSpace">bos.fs_GetFreeSpace</a></td><td><a href="#fs_GetFreeSpace">02262C</a></td></tr>
<tr><td><a href="#fs_GetFDPtrRaw">bos.fs_GetFDPtrRaw</a></td><td><a href="#fs_GetFDPtrRaw">022630</a></td></tr>
<tr><td><a href="#fs_GetFDLenRaw">bos.fs_GetFDLenRaw</a></td><td><a href="#fs_GetFDLenRaw">022634</a></td></tr>
<tr><td><a href="#_OP1ToPath">bos._OP1ToPath</a></td><td><a href="#_OP1ToPath">022638</a></td></tr>
<tr><td><a href="#th_WaitKeyCycle">bos.th_WaitKeyCycle</a></td><td><a href="#th_WaitKeyCycle">02263C</a></td></tr>
<tr><td><a href="#fs_JoinPath">bos.fs_JoinPath</a></td><td><a href="#fs_JoinPath">022640</a></td></tr>
<tr><td><a href="#sys_MallocPersistent">bos.sys_MallocPersistent</a></td><td><a href="#sys_MallocPersistent">022644</a></td></tr>
<tr><td><a href="#sys_OpenFileInVar">bos.sys_OpenFileInVar</a></td><td><a href="#sys_OpenFileInVar">022648</a></td></tr>
<tr><td><a href="#fs_BaseName">bos.fs_BaseName</a></td><td><a href="#fs_BaseName">02264C</a></td></tr>
<tr><td><a href="#fs_MoveFile">bos.fs_MoveFile</a></td><td><a href="#fs_MoveFile">022650</a></td></tr>
<tr><td><a href="#fs_WriteDirectly">bos.fs_WriteDirectly</a></td><td><a href="#fs_WriteDirectly">022654</a></td></tr>
<tr><td><a href="#_UnpackUpdates">bos._UnpackUpdates</a></td><td><a href="#_UnpackUpdates">022658</a></td></tr>
<tr><td><a href="#sys_ReadSectorCache">bos.sys_ReadSectorCache</a></td><td><a href="#sys_ReadSectorCache">02265C</a></td></tr>
<tr><td><a href="#sys_WriteSectorCache">bos.sys_WriteSectorCache</a></td><td><a href="#sys_WriteSectorCache">022660</a></td></tr>
<tr><td><a href="#sys_OpenFileInLib">bos.sys_OpenFileInLib</a></td><td><a href="#sys_OpenFileInLib">022664</a></td></tr>
<tr><td><a href="#sys_LoadHookThreads">bos.sys_LoadHookThreads</a></td><td><a href="#sys_LoadHookThreads">022668</a></td></tr>
<tr><td><a href="#gfx_BlitScreen">bos.gfx_BlitScreen</a></td><td><a href="#gfx_BlitScreen">02266C</a></td></tr>
<tr><td><a href="#th_CreateThread">bos.th_CreateThread</a></td><td><a href="#th_CreateThread">022670</a></td></tr>
<tr><td><a href="#gfx_ZeroVRAM">bos.gfx_ZeroVRAM</a></td><td><a href="#gfx_ZeroVRAM">022674</a></td></tr>
<tr><td><a href="#th_KillThread">bos.th_KillThread</a></td><td><a href="#th_KillThread">022678</a></td></tr>
<tr><td><a href="#fs_GetFilePtr">bos.fs_GetFilePtr</a></td><td><a href="#fs_GetFilePtr">02267C</a></td></tr>
<tr><td><a href="#fs_GetFDPtr">bos.fs_GetFDPtr</a></td><td><a href="#fs_GetFDPtr">022680</a></td></tr>
<tr><td><a href="#fs_GetFDLen">bos.fs_GetFDLen</a></td><td><a href="#fs_GetFDLen">022684</a></td></tr>
<tr><td><a href="#fs_ArcUnarcFD">bos.fs_ArcUnarcFD</a></td><td><a href="#fs_ArcUnarcFD">022688</a></td></tr>
<tr><td><a href="#util_Zx0Decompress">bos.util_Zx0Decompress</a></td><td><a href="#util_Zx0Decompress">02268C</a></td></tr>
<tr><td><a href="#sys_WaitKeyUnpress">bos.sys_WaitKeyUnpress</a></td><td><a href="#sys_WaitKeyUnpress">022690</a></td></tr>
<tr><td><a href="#sys_MallocDupStr">bos.sys_MallocDupStr</a></td><td><a href="#sys_MallocDupStr">022694</a></td></tr>
<tr><td><a href="#sys_MallocDupStrN">bos.sys_MallocDupStrN</a></td><td><a href="#sys_MallocDupStrN">022698</a></td></tr>
<tr><td><a href="#_SearchSymTable">bos._SearchSymTable</a></td><td><a href="#_SearchSymTable">02269C</a></td></tr>
<tr><td><a href="#fs_Rename">bos.fs_Rename</a></td><td><a href="#fs_Rename">0226A0</a></td></tr>
<tr><td><a href="#fs_AllocChk">bos.fs_AllocChk</a></td><td><a href="#fs_AllocChk">0226A4</a></td></tr>
<tr><td><a href="#sys_GetExecType">bos.sys_GetExecType</a></td><td><a href="#sys_GetExecType">0226A8</a></td></tr>
<tr><td><a href="#sys_GetExecTypeFD">bos.sys_GetExecTypeFD</a></td><td><a href="#sys_GetExecTypeFD">0226AC</a></td></tr>
<tr><td><a href="#util_Zx7Compress">bos.util_Zx7Compress</a></td><td><a href="#util_Zx7Compress">0226B0</a></td></tr>
</table><div id="boot_os                  "><h1>boot_os                  </h1>	<h3>syscall Adress 020108</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="handle_interrupt"><h1>handle_interrupt</h1>	<h3>syscall Adress 02010C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="HandleInstruction        "><h1>HandleInstruction        </h1>	<h3>syscall Adress 020110</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="sc_HandleSysCall         "><h1>sc_HandleSysCall         </h1>	<h3>syscall Adress 020114</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="handle_offsetinstruction "><h1>handle_offsetinstruction </h1>	<h3>syscall Adress 02011C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="sys_ExecuteFile"><h1>sys_ExecuteFile</h1>	<h3>syscall Adress 022400</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Execute a file.</td><td>int sys_ExecuteFile(const char *path, char *args);</td><td>-1 and Cf set if file does not exist or is not a valid executable format, or if malloc failed somewhere.<br>
ExecutingFileFd set to point to file descriptor. -1 if file not found, -2 if /var/PATH not found.</td><td></td><td>
</td></tr>
</table></div><div id="os_GetOSInfo"><h1>os_GetOSInfo</h1>	<h3>syscall Adress 022404</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_OpenFile"><h1>fs_OpenFile</h1>	<h3>syscall Adress 022408</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Opens a file from a path and returns file descriptor.</td><td>void *fs_OpenFile(char *path);</td><td>hl = file descriptor. hl is -1 and Cf set if file does not exist.</td><td></td><td>
</td></tr>
</table></div><div id="fs_GetSectorAddress"><h1>fs_GetSectorAddress</h1>	<h3>syscall Adress 02240C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>get the memory address of a given sector address.</td><td>void *fs_GetSectorAddress(uint16_t sector);</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_CheckDirExists"><h1>fs_CheckDirExists</h1>	<h3>syscall Adress 022410</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>check if a directory exists.</td><td>bool fs_CheckDirExists(char *path);</td><td>true if path exists, else false</td><td></td><td>
</td></tr>
</table></div><div id="fs_CeilDivBySector"><h1>fs_CeilDivBySector</h1>	<h3>syscall Adress 022414</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>divide by sector size, adding 1 to the result if there is a remainder. Returns 1 if HL is 0</td><td>HL = number to divide</td><td>HL = result</td><td></td><td>
</td></tr>
</table></div><div id="fs_CopyFileName"><h1>fs_CopyFileName</h1>	<h3>syscall Adress 022418</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>copies file name from file descriptor</td><td>char *fs_CopyFileName(void *fd);</td><td>returns -1 on fail</td><td></td><td>
Allocates space for copied file name</td></tr>
</table></div><div id="fs_Read"><h1>fs_Read</h1>	<h3>syscall Adress 02241C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>read data from a file into RAM</td><td>int fs_Read(void *dest, int len, uint8_t count, void *fd, int offset);</td><td>number of bytes read</td><td></td><td>
</td></tr>
</table></div><div id="fs_Write"><h1>fs_Write</h1>	<h3>syscall Adress 022420</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>write data to a file</td><td>void *fs_Write(void *data, int len, uint8_t count, void *fd, int offset);</td><td>New file descriptor or -1 and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="sys_AddHLAndA"><h1>sys_AddHLAndA</h1>	<h3>syscall Adress 022424</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>HL+=A</td><td>HL number<br>
A increment</td><td>HL number+increment</td><td></td><td>
</td></tr>
</table></div><div id="sys_AnyKey"><h1>sys_AnyKey</h1>	<h3>syscall Adress 022428</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Scans the keypad and updates data registers; checking if a key was pressed</td><td></td><td>0 if no keys pressed</td><td></td><td>
</td></tr>
</table></div><div id="sys_FreeAll"><h1>sys_FreeAll</h1>	<h3>syscall Adress 02242C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Free all memory malloc'd by sys_Malloc</td><td>void sys_FreeAll(void);</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_GetKey"><h1>sys_GetKey</h1>	<h3>syscall Adress 022430</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Return current keypress</td><td></td><td>A keypress<br>
z if no key pressed</td><td></td><td>
</td></tr>
</table></div><div id="sys_KbScan"><h1>sys_KbScan</h1>	<h3>syscall Adress 022434</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Scans the keypad and updates data registers</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_Malloc"><h1>sys_Malloc</h1>	<h3>syscall Adress 022438</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Allocate memory</td><td>void *sys_Malloc(size_t amt);</td><td>hl = malloc'd bytes. hl = 0 if failed to malloc<br>
Cf set if failed to malloc</td><td></td><td>
</td></tr>
</table></div><div id="fs_CreateRamFile"><h1>fs_CreateRamFile</h1>	<h3>syscall Adress 02243C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Create a file descriptor with contents stored in RAM.</td><td>fs_CreateRamFile(const char *path, uint8_t flags, void *data, size_t len);</td><td>HL = file descriptor or HL=0 and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="sys_MemSet"><h1>sys_MemSet</h1>	<h3>syscall Adress 022440</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>draws a horizontal line to the current buffer</td><td>HL line X coordinate<br>
E line Y coordinate<br>
BC line length</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_AllocRam"><h1>fs_AllocRam</h1>	<h3>syscall Adress 022444</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_WaitKey"><h1>sys_WaitKey</h1>	<h3>syscall Adress 022448</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Wait until a key is pressed and return it</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_WaitKeyCycle"><h1>sys_WaitKeyCycle</h1>	<h3>syscall Adress 02244C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Wait until a key is pressed, then wait until it's released, then return the keycode</td><td></td><td>A = keycode</td><td></td><td>
</td></tr>
</table></div><div id="gui_DrawConsoleWindow"><h1>gui_DrawConsoleWindow</h1>	<h3>syscall Adress 022450</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>clear the screen and display a string</td><td>hl = string</td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_Input"><h1>gui_Input</h1>	<h3>syscall Adress 022454</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>get user input</td><td>uint8_t gui_Input(char *buffer, int max_len);</td><td>0 if user exit, 1 if user enter, 9/12 if user presses down/up arrow key</td><td></td><td>
</td></tr>
</table></div><div id="gui_NewLine"><h1>gui_NewLine</h1>	<h3>syscall Adress 022458</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_Print"><h1>gui_Print</h1>	<h3>syscall Adress 02245C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_PrintInt"><h1>gui_PrintInt</h1>	<h3>syscall Adress 022460</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Print an integer. Does not swap buffers.</td><td>hl = integer</td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_Scroll"><h1>gui_Scroll</h1>	<h3>syscall Adress 022464</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_BlitBuffer"><h1>gfx_BlitBuffer</h1>	<h3>syscall Adress 022468</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_PrintString"><h1>gfx_PrintString</h1>	<h3>syscall Adress 02246C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_MemClear"><h1>_MemClear</h1>	<h3>syscall Adress 022470</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Clear (Zero) BC bytes at HL</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_PushOP1"><h1>_PushOP1</h1>	<h3>syscall Adress 022474</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="_PopOP1"><h1>_PopOP1</h1>	<h3>syscall Adress 022478</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="_Mov9ToOP1"><h1>_Mov9ToOP1</h1>	<h3>syscall Adress 02247C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>move 9 bytes from HL to OP1</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_CpHLDE"><h1>_CpHLDE</h1>	<h3>syscall Adress 022480</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>compare HL to DE. Returns the resultant of "sbc hl,de" without modifying either.</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_Mov8b"><h1>_Mov8b</h1>	<h3>syscall Adress 022484</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>copy 8 bytes from HL to DE</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_ChkFindSym"><h1>_ChkFindSym</h1>	<h3>syscall Adress 022488</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Search for a TI variable in directories listed by $TIVARS</td><td>OP1 containing 1 byte var type, 8 byte file name</td><td>HL = pointer to 2 byte file length<br>
DE = pointer to file data<br>
Cf set if file not found or otherwise cannot be opened.</td><td></td><td>
</td></tr>
</table></div><div id="_LoadDEInd_s"><h1>_LoadDEInd_s</h1>	<h3>syscall Adress 02248C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>load DE with 16-bit value at HL, advancing HL+=2</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_EnoughMem"><h1>_EnoughMem</h1>	<h3>syscall Adress 022490</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Check if there are HL bytes avalible in userMem</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_InsertMem"><h1>_InsertMem</h1>	<h3>syscall Adress 022494</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>insert HL bytes into a ram file at address DE</td><td>hl = bytes to insert, de = address to insert at</td><td>hl = new end of file, de = pointer to the space inserted</td><td></td><td>
</td></tr>
</table></div><div id="_SetHLUTo0"><h1>_SetHLUTo0</h1>	<h3>syscall Adress 022498</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_PutS"><h1>_PutS</h1>	<h3>syscall Adress 02249C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Print a string to the current cursor position and blit the buffer when finished.</td><td>HL = string</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_GetCSC"><h1>_GetCSC</h1>	<h3>syscall Adress 0224A0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Get the current keypress and return it in A</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_NewLine"><h1>_NewLine</h1>	<h3>syscall Adress 0224A4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="_ClrScrn"><h1>_ClrScrn</h1>	<h3>syscall Adress 0224A8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Clear the screen and back buffer</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_HomeUp"><h1>_HomeUp</h1>	<h3>syscall Adress 0224AC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Set the cursor position to 0,0</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_ErrMemory"><h1>_ErrMemory</h1>	<h3>syscall Adress 0224B0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Display a memory error message</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_DrawStatusBar"><h1>_DrawStatusBar</h1>	<h3>syscall Adress 0224B4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Clear the screen and display the current working directory.</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_os_GetSystemInfo"><h1>_os_GetSystemInfo</h1>	<h3>syscall Adress 0224B8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>return system info. Compatibility define. It actually returns 0xFF0000. lol</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_UsbPowerVbus"><h1>_UsbPowerVbus</h1>	<h3>syscall Adress 0224BC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>I honestly don't know. Included this routine for compatibility with USBDDRVCE.</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_UsbUnpowerVbus"><h1>_UsbUnpowerVbus</h1>	<h3>syscall Adress 0224C0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>I honestly don't know. Included for compatibility with USBDRVCE.</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_EraseFlashSector"><h1>sys_EraseFlashSector</h1>	<h3>syscall Adress 0224C4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Erase flash sector</td><td>A sector to erase</td><td></td><td></td><td>
calls boot routine $2DC</td></tr>
</table></div><div id="sys_FlashUnlock"><h1>sys_FlashUnlock</h1>	<h3>syscall Adress 0224C8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_FlashLock"><h1>sys_FlashLock</h1>	<h3>syscall Adress 0224CC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_CreateFile"><h1>fs_CreateFile</h1>	<h3>syscall Adress 0224D0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Create a file given a path and return a file descriptor.</td><td>void *fs_CreateFile(const char *path, uint8_t flags, int len);</td><td>file descriptor. Returns 0 if failed to create file.</td><td></td><td>
if len is zero, the file data section will not be initialized.<br>
if len is greater than 65536, this routine fails.</td></tr>
</table></div><div id="strupper"><h1>strupper</h1>	<h3>syscall Adress 0224D4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>convert a string to uppercase</td><td>HL pointer to string</td><td>HL HL+strlen(HL)</td><td></td><td>
</td></tr>
</table></div><div id="strlower"><h1>strlower</h1>	<h3>syscall Adress 0224D8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>convert a string to lowercase</td><td>HL pointer to string</td><td>HL HL+strlen(HL)</td><td></td><td>
</td></tr>
</table></div><div id="fs_AbsPath"><h1>fs_AbsPath</h1>	<h3>syscall Adress 0224DC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>get absolute path representation of hl</td><td>char *fs_AbsPath(const char *path);</td><td>hl = absolute path. Will be the same as the input if it is already an absolute path<br>
Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_MultByBytesPerSector"><h1>fs_MultByBytesPerSector</h1>	<h3>syscall Adress 0224E0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>multiply by the number of bytes per sector</td><td>HL = number</td><td>HL*=fs_sector_size</td><td></td><td>
</td></tr>
</table></div><div id="_LoadLibraryOP1"><h1>_LoadLibraryOP1</h1>	<h3>syscall Adress 0224E4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>locate and return a pointer to a library from a ".dll" file in a directory listed in "/lib"</td><td>OP1 name of library</td><td>hl points to file length, de points to file data. Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_OpenFileInDir"><h1>fs_OpenFileInDir</h1>	<h3>syscall Adress 0224E8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Opens a file given a path and a file descriptor to start searching in. Returns file descriptor.</td><td>void *fs_OpenFileInDir(char *path, void *dir);</td><td>hl = file descriptor. hl is -1 if file does not exist, or if trying to start search in a file.</td><td></td><td>
</td></tr>
</table></div><div id="fs_SetSize"><h1>fs_SetSize</h1>	<h3>syscall Adress 0224EC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Resizes a file descriptor.</td><td>void *fs_SetSize(int len, void *fd);</td><td>new file descriptor if success, -1 and Cf set if fail</td><td></td><td>
New file contents will be empty, but old file data will be preserved until the next cleanup.</td></tr>
</table></div><div id="fs_WriteFile"><h1>fs_WriteFile</h1>	<h3>syscall Adress 0224F0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Overwrite all data stored in a file from a given data pointer.</td><td>int WriteFile(void *data, int len, void *fd);</td><td>New file descriptor. -1 if failed to write</td><td></td><td>
</td></tr>
</table></div><div id="sys_HLToString"><h1>sys_HLToString</h1>	<h3>syscall Adress 0224F4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>convert a number to a string</td><td>HL = number to convert</td><td>DE = string<br>
string stored at gfx_string_temp</td><td></td><td>
</td></tr>
</table></div><div id="fs_DeleteFile"><h1>fs_DeleteFile</h1>	<h3>syscall Adress 0224F8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>delete a file/directory given a path</td><td>bool fs_DeleteFile(const char *name);</td><td>true/nz if success, false/zf if fail</td><td></td><td>
</td></tr>
</table></div><div id="_DelVar"><h1>_DelVar</h1>	<h3>syscall Adress 0224FC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>delete a file in the /usr/tivars/ directory</td><td>OP1 = type byte, 8 byte name of var to delete</td><td>Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="_CreateVar"><h1>_CreateVar</h1>	<h3>syscall Adress 022500</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>create a ram file in the /tivars/ directory</td><td>OP1+1 = 8 byte name of var to create<br>
A = var type<br>
hl = length to allocate for file</td><td>hl = pointer to (VAT entry) 2 byte file length, de = pointer to file data<br>
Cf set and HL = -1 if failed</td><td></td><td>
</td></tr>
</table></div><div id="gui_InputNoClear"><h1>gui_InputNoClear</h1>	<h3>syscall Adress 022504</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>get user input without clearing the provided buffer first.</td><td>uint8_t gui_InputNoClear(char *buffer, int max_len);</td><td>0 if user exit, 1 if user enter, 9/12 if user presses down/up arrow key</td><td></td><td>
</td></tr>
</table></div><div id="fs_InitClusterMap"><h1>fs_InitClusterMap</h1>	<h3>syscall Adress 022508</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>initialize cluster map given data within the file system.</td><td>void fs_InitClusterMap(void);</td><td></td><td></td><td>
uses the first half of vRam as scrap.</td></tr>
</table></div><div id="sys_WriteFlash"><h1>sys_WriteFlash</h1>	<h3>syscall Adress 02250C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>write BC bytes to flash from HL to DE.</td><td>HL, DE, BC</td><td>DE points to byte following written data</td><td></td><td>
</td></tr>
</table></div><div id="sys_WriteFlashA"><h1>sys_WriteFlashA</h1>	<h3>syscall Adress 022510</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>write a byte from A to flash at address DE</td><td>A, DE</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_JoinArgv"><h1>sys_JoinArgv</h1>	<h3>syscall Adress 022514</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Join argv into a space-delimited string.</td><td>char *sys_JoinArgv(int argc, char *argv[]);</td><td>Pointer to string.</td><td></td><td>
</td></tr>
</table></div><div id="fs_PathLen"><h1>fs_PathLen</h1>	<h3>syscall Adress 022518</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Get the length of a path string</td><td>int fs_PathLen(const char *path);</td><td>hl = length of path, de = pointer to end of path, a = end of path character</td><td></td><td>
</td></tr>
</table></div><div id="fs_ParentDir"><h1>fs_ParentDir</h1>	<h3>syscall Adress 02251C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>return a string representing the parent directory of a given path.</td><td>char *fs_ParentDir(const char *path);</td><td>HL = string representing path to parent directory. Returns -1 and Cf on fail.</td><td></td><td>
</td></tr>
</table></div><div id="fs_StrToFileEntry"><h1>fs_StrToFileEntry</h1>	<h3>syscall Adress 022520</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>convert a file.ext string to a file entry</td><td>char *fs_StrToFileEntry(char *dest, const char *src);</td><td>pointer to file entry, 0 if failed. First byte of file entry will be fsentry_longfilename if file's name is too long for an 8.3 path.<br>
Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_DirList"><h1>fs_DirList</h1>	<h3>syscall Adress 022524</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>list items in a directory</td><td>int fs_DirList(void **buffer, const char *path, unsigned int num, unsigned int skip);</td><td>Returns number of items read. Returns -1 and Cf on fail.</td><td></td><td>
integer arguments "num" and "skip" must be less than 65536.</td></tr>
</table></div><div id="sys_Free"><h1>sys_Free</h1>	<h3>syscall Adress 022528</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Free as block of memory malloc'd by sys_Malloc</td><td>void sys_Free(void *ptr);</td><td>Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="sys_CallExecuteFile"><h1>sys_CallExecuteFile</h1>	<h3>syscall Adress 02252C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Jump execution to an executable file and return to caller afterwards</td><td>hl = program file to execute<br>
de = arguments<br>
bc = program file to return to</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_JumpExecuteFile"><h1>sys_JumpExecuteFile</h1>	<h3>syscall Adress 022530</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Jump execution to an executable file</td><td>hl = file to execute<br>
de = arguments</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_OpenDevice"><h1>sys_OpenDevice</h1>	<h3>syscall Adress 022534</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Initialize a device (if needed) and return a device structure.</td><td>device_t *sys_OpenDevice(const char *name);</td><td>pointer to device structure. (file data)<br>
hl=-1 and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="fs_CopyFile"><h1>fs_CopyFile</h1>	<h3>syscall Adress 022538</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Copy a file given paths and return a file descriptor.</td><td>void *fs_CopyFile(const char *src, const char *dest);</td><td>file descriptor of new file. Returns 0 if failed.</td><td></td><td>
</td></tr>
</table></div><div id="fs_GetSector"><h1>fs_GetSector</h1>	<h3>syscall Adress 022548</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>get the sector a given address lies within</td><td>int fs_GetSector(void *address);</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_WriteByte"><h1>fs_WriteByte</h1>	<h3>syscall Adress 02254C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>write a byte into a file if the byte can be written</td><td>bool fs_WriteByte(uint8_t byte, void *fd, int offset);</td><td></td><td></td><td>
Fails if the byte can't be written without swapping</td></tr>
</table></div><div id="fs_RenameFile"><h1>fs_RenameFile</h1>	<h3>syscall Adress 022550</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>rename a file</td><td>void *fs_RenameFile(const char *directory, const char *old_name, const char *new_name);</td><td>file descriptor. returns zero if failed</td><td></td><td>
</td></tr>
</table></div><div id="_SetCursorPos"><h1>_SetCursorPos</h1>	<h3>syscall Adress 022554</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Set the text cursor position</td><td>void _SetCursorPos(uint8_t row, uint8_t col);</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_CreateDir"><h1>fs_CreateDir</h1>	<h3>syscall Adress 022558</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Create a directory given a path and return a file descriptor.</td><td>void *fs_CreateDir(const char *path, uint8_t flags);</td><td>file descriptor. Returns 0 if failed to create directory. </td><td></td><td>
</td></tr>
</table></div><div id="gfx_BufClear"><h1>gfx_BufClear</h1>	<h3>syscall Adress 02255C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>clears the back buffer</td><td>A color to fill with</td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_LcdClear"><h1>gfx_LcdClear</h1>	<h3>syscall Adress 022560</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>clears the lcd</td><td>A color to fill with</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_SanityCheck"><h1>fs_SanityCheck</h1>	<h3>syscall Adress 022564</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Sanity check the filesystem and initialize it as needed</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_SetOnInterruptHandler"><h1>sys_SetOnInterruptHandler</h1>	<h3>syscall Adress 022568</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Set an error handler for an interrupt caused by the [On] key.</td><td>void *sys_SetOnInterruptHandler(void (*handler)(void));</td><td>Returns previous error handler.</td><td></td><td>
user error handler is called after the interrupt is handled.</td></tr>
</table></div><div id="gui_PrintChar"><h1>gui_PrintChar</h1>	<h3>syscall Adress 02256C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Print a character to the back buffer and advance the text cursor</td><td>A = character to print</td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_SetDraw"><h1>gfx_SetDraw</h1>	<h3>syscall Adress 022570</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_PrintString"><h1>gui_PrintString</h1>	<h3>syscall Adress 022574</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>print a string to the current lcd buffer, advancing curcol</td><td>HL pointer to string</td><td>HL pointer to character after the last one printed<br>
Cf set if a control code is encountered or if the text would overflow the line.<br>
A = control code if a control code is encountered. (Cf will be set)</td><td></td><td>
If you need a routine callable from C, this is not the one you'll want to use.</td></tr>
</table></div><div id="gui_PrintLine"><h1>gui_PrintLine</h1>	<h3>syscall Adress 022578</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_PrintUInt"><h1>gui_PrintUInt</h1>	<h3>syscall Adress 02257C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Print an unsigned integer. Dos not swap buffers.</td><td>hl = integer</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_GetFilePtrRaw"><h1>fs_GetFilePtrRaw</h1>	<h3>syscall Adress 022588</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>get a pointer to a file's data section</td><td>void *fs_GetFilePtrRaw(const char *path);</td><td>HL = file data pointer, BC = file data length, A = file flags, Cf set and HL = -1 if failed</td><td></td><td>
</td></tr>
</table></div><div id="sys_ExecuteFileHL"><h1>sys_ExecuteFileHL</h1>	<h3>syscall Adress 022590</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>execute a file given a pointer to it's path in HL</td><td>HL = pointer to file path</td><td>same as sys_ExecuteFile</td><td></td><td>
</td></tr>
</table></div><div id="sys_TurnOff"><h1>sys_TurnOff</h1>	<h3>syscall Adress 022594</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>turns off the calculator until the on key is pressed.</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_NextProcessId"><h1>sys_NextProcessId</h1>	<h3>syscall Adress 022598</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Increment the process ID.</td><td>void sys_NextProcessId(void);</td><td></td><td></td><td>
Used for categorizing malloc'd memory</td></tr>
</table></div><div id="sys_PrevProcessId"><h1>sys_PrevProcessId</h1>	<h3>syscall Adress 02259C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Decrement the process ID.</td><td>void sys_PrevProcessId(void);</td><td></td><td></td><td>
Used for categorizing malloc'd memory</td></tr>
</table></div><div id="sys_FreeProcessId"><h1>sys_FreeProcessId</h1>	<h3>syscall Adress 0225A0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Free all memory allocated by a given process ID</td><td>void sys_FreeProcessId(uint8_t id);</td><td></td><td></td><td>
DO NOT free process ID 1 since it is used by the OS and should be preserved.</td></tr>
</table></div><div id="fs_GarbageCollect"><h1>fs_GarbageCollect</h1>	<h3>syscall Adress 0225A4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Clean up the filesystem, resetting freed areas.</td><td>None</td><td>None</td><td></td><td>
</td></tr>
</table></div><div id="gfx_SwapTextColors"><h1>gfx_SwapTextColors</h1>	<h3>syscall Adress 0225A8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Swap lcd_text_fg and lcd_text_fg2</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_WriteNewFile"><h1>fs_WriteNewFile</h1>	<h3>syscall Adress 0225AC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Create and write a new file</td><td>void *fs_WriteNewFile(const char *name, uint8_t properties, void *data, int len);</td><td>HL = file descriptor. HL = -1 and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="gfx_SetFont"><h1>gfx_SetFont</h1>	<h3>syscall Adress 0225B0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>set the current font</td><td>void *gfx_SetFont(void *data)</td><td>HL = old font data</td><td></td><td>
data structure: uint8_t num_bitmaps, uint8_t spacing[], uint8_t data[]</td></tr>
</table></div><div id="gfx_SetDefaultFont"><h1>gfx_SetDefaultFont</h1>	<h3>syscall Adress 0225B4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Reset the current font to the default built-in font</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_FreeRunningProcessId"><h1>sys_FreeRunningProcessId</h1>	<h3>syscall Adress 0225B8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Free all memory allocated by the current process ID</td><td>void sys_FreeProcessId(void);</td><td></td><td></td><td>
Automatically called after program runs</td></tr>
</table></div><div id="util_Zx7Decompress"><h1>util_Zx7Decompress</h1>	<h3>syscall Adress 0225BC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>decompress a block of zx7-compressed data into a user-provided RAM buffer</td><td>void util_Zx7Decompress(void *dest, void *src);</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_CheckMallocRAM"><h1>sys_CheckMallocRAM</h1>	<h3>syscall Adress 0225C0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Check how much memory is free in Malloc RAM</td><td>int sys_CheckMallocRAM(void);</td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_Compute"><h1>gfx_Compute</h1>	<h3>syscall Adress 0225C4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>compute draw location on the current lcd buffer from XY coodinate.</td><td>HL X coordinate<br>
E Y coordinate</td><td>HL pointer to draw location</td><td></td><td>
</td></tr>
</table></div><div id="gfx_FillRectangle"><h1>gfx_FillRectangle</h1>	<h3>syscall Adress 0225C8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_FillScreen"><h1>gfx_FillScreen</h1>	<h3>syscall Adress 0225CC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_GetFontPtr"><h1>gfx_GetFontPtr</h1>	<h3>syscall Adress 0225D0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>get pointer to font data</td><td></td><td>hl = current font data</td><td></td><td>
</td></tr>
</table></div><div id="gfx_HorizLine"><h1>gfx_HorizLine</h1>	<h3>syscall Adress 0225D4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_InitStdPalette"><h1>gfx_InitStdPalette</h1>	<h3>syscall Adress 0225D8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Initialise the standard (8bpp) XLibC palette</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_NextLine"><h1>gfx_NextLine</h1>	<h3>syscall Adress 0225DC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>moves the text position 9 rows ahead, and moves the collumn to zero.</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_PrintChar"><h1>gfx_PrintChar</h1>	<h3>syscall Adress 0225E0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_PrintHexA"><h1>gfx_PrintHexA</h1>	<h3>syscall Adress 0225E4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_PrintUInt"><h1>gfx_PrintUInt</h1>	<h3>syscall Adress 0225E8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_Rectangle"><h1>gfx_Rectangle</h1>	<h3>syscall Adress 0225EC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_Set8bpp"><h1>gfx_Set8bpp</h1>	<h3>syscall Adress 0225F0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>set the lcd to 8bpp mode</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_Set16bpp"><h1>gfx_Set16bpp</h1>	<h3>syscall Adress 0225F4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>set the lcd to 16bpp mode</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_SetTextXY"><h1>gfx_SetTextXY</h1>	<h3>syscall Adress 0225F8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_Sprite"><h1>gfx_Sprite</h1>	<h3>syscall Adress 0225FC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_Sprite2x"><h1>gfx_Sprite2x</h1>	<h3>syscall Adress 022600</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>draws a sprite to the current buffer at 2x scale</td><td>HL pointer to sprite<br>
BC X<<8 + Y</td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_VertLine"><h1>gfx_VertLine</h1>	<h3>syscall Adress 022604</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_Malloc32Align32"><h1>sys_Malloc32Align32</h1>	<h3>syscall Adress 022608</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Allocate 32 bytes of memory, 32-byte aligned.</td><td>void *sys_Malloc32Align32(void);</td><td>hl = malloc'd bytes. hl = 0 if failed to malloc<br>
Cf set if failed to malloc</td><td></td><td>
BOS's memory allocation is already 32-byte aligned</td></tr>
</table></div><div id="sys_Malloc64Align256"><h1>sys_Malloc64Align256</h1>	<h3>syscall Adress 02260C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Allocate 64 bytes of memory, 256-byte aligned.</td><td>void *sys_Malloc64Align256(void);</td><td>hl = malloc'd bytes. hl = 0 if failed to malloc<br>
Cf set if failed to malloc</td><td></td><td>
</td></tr>
</table></div><div id="gfx_PrintStringXY"><h1>gfx_PrintStringXY</h1>	<h3>syscall Adress 022610</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_GetTextX"><h1>gfx_GetTextX</h1>	<h3>syscall Adress 022614</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_GetTextY"><h1>gfx_GetTextY</h1>	<h3>syscall Adress 022618</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_OpenFileInPath"><h1>sys_OpenFileInPath</h1>	<h3>syscall Adress 022624</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>open a file, looking in directories from $PATH variable if file not found</td><td>void *sys_OpenFileInPath(const char *path);</td><td>pointer to file descriptor</td><td></td><td>
</td></tr>
</table></div><div id="sys_VarString"><h1>sys_VarString</h1>	<h3>syscall Adress 022628</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Similar to sprintf but uses system vars and malloc's the output buffer.</td><td>char *sys_VarString(const char *str);</td><td>hl string where $VAR's are replaced with their respective values. Returns -1 and Cf set if failed.</td><td></td><td>
$VAR must be terminated with a space " " which is not included in the output.</td></tr>
</table></div><div id="fs_GetFreeSpace"><h1>fs_GetFreeSpace</h1>	<h3>syscall Adress 02262C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Return remaining free space in the filesystem</td><td>int fs_GetFreeSpace(void);</td><td>filesystem remaining space in bytes</td><td></td><td>
</td></tr>
</table></div><div id="fs_GetFDPtrRaw"><h1>fs_GetFDPtrRaw</h1>	<h3>syscall Adress 022630</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Return pointer to file data given a file descriptor</td><td>void *fs_GetFDPtrRaw(void *fd);</td><td>pointer to file data, or -1 and Cf set if file data has not been allocated yet.</td><td></td><td>
</td></tr>
</table></div><div id="fs_GetFDLenRaw"><h1>fs_GetFDLenRaw</h1>	<h3>syscall Adress 022634</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Return length of file data given a file descriptor</td><td>int fs_GetFDLenRaw(void *fd);</td><td>length of file data. Will be 0 if data has not been initizlized yet.</td><td></td><td>
</td></tr>
</table></div><div id="_OP1ToPath"><h1>_OP1ToPath</h1>	<h3>syscall Adress 022638</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Convert a variable name from OP1 into a BOS file name.</td><td>OP1 variable type byte, 8 byte name</td><td>hl = path<br>
Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="th_WaitKeyCycle"><h1>th_WaitKeyCycle</h1>	<h3>syscall Adress 02263C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Starts a thread that does nothing until a key is pressed and unpressed, passes the keypress to the caller via a callback function, then stops.</td><td>int th_WaitKeyCycle(void (*callback)(uint8_t key));</td><td>returns 0 and Cf unset on success, -1 and Cf set on fail.</td><td></td><td>
Starts a thread, which won't do anything until handled.</td></tr>
</table></div><div id="fs_JoinPath"><h1>fs_JoinPath</h1>	<h3>syscall Adress 022640</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>join two filesystem paths</td><td>char *fs_JoinPath(const char *path1, const char *path2);</td><td>hl = resultant path.<br>
Cf set, hl = -1 if failed</td><td></td><td>
</td></tr>
</table></div><div id="sys_MallocPersistent"><h1>sys_MallocPersistent</h1>	<h3>syscall Adress 022644</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Allocate memory to be treated as persistent</td><td>same as sys_Malloc</td><td>same as sys_Malloc</td><td></td><td>
</td></tr>
</table></div><div id="sys_OpenFileInVar"><h1>sys_OpenFileInVar</h1>	<h3>syscall Adress 022648</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>open a file, looking in directories from var variable if file not found</td><td>void *sys_OpenFileInVar(const char *path, const char *var);</td><td>pointer to file descriptor</td><td></td><td>
</td></tr>
</table></div><div id="fs_BaseName"><h1>fs_BaseName</h1>	<h3>syscall Adress 02264C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>return the last path word of a path</td><td>char *fs_BaseName(const char *path);</td><td>copy of last path word, or same as input if it is the only path word, or pointer to '/' if that is the last character of the path.</td><td></td><td>
</td></tr>
</table></div><div id="fs_MoveFile"><h1>fs_MoveFile</h1>	<h3>syscall Adress 022650</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Move a file given paths and return a file descriptor.</td><td>void *fs_MoveFile(const char *src, const char *dest);</td><td>file descriptor of new file. Returns 0 if failed.</td><td></td><td>
</td></tr>
</table></div><div id="fs_WriteDirectly"><h1>fs_WriteDirectly</h1>	<h3>syscall Adress 022654</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Attempt to write data to a file directly, failing if the data can't be written correctly or if the file isnt large enough.</td><td>void *fs_WriteDirectly(void *data, int len, uint8_t count, void *fd, int offset);</td><td>New file descriptor or -1 and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="_UnpackUpdates"><h1>_UnpackUpdates</h1>	<h3>syscall Adress 022658</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_ReadSectorCache"><h1>sys_ReadSectorCache</h1>	<h3>syscall Adress 02265C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Read flash sector A into the sector cache (VRAM)</td><td></td><td>returns pointer to sector cache in hl</td><td></td><td>
</td></tr>
</table></div><div id="sys_WriteSectorCache"><h1>sys_WriteSectorCache</h1>	<h3>syscall Adress 022660</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Write the currently cached sector back to flash sector A</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_OpenFileInLib"><h1>sys_OpenFileInLib</h1>	<h3>syscall Adress 022664</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>open a file, looking in directories listed in /var/LIB.</td><td>void *sys_OpenFileInLib(const char *path);</td><td>pointer to file descriptor</td><td></td><td>
</td></tr>
</table></div><div id="sys_LoadHookThreads"><h1>sys_LoadHookThreads</h1>	<h3>syscall Adress 022668</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>run threads given a pointer to a file path structure</td><td>void sys_LoadHookThreads(void *ptr, size_t len);</td><td></td><td></td><td>
data structure: type byte, entry length byte, offset of data in file (2 bytes), stack size byte, file name (null-terminated), end of entry</td></tr>
</table></div><div id="gfx_BlitScreen"><h1>gfx_BlitScreen</h1>	<h3>syscall Adress 02266C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>copies the lcd to the back buffer</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="th_CreateThread"><h1>th_CreateThread</h1>	<h3>syscall Adress 022670</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>spawn a thread</td><td>uint8_t th_CreateThread(void *pc, void *sp, int argc, char **argv);</td><td>thread id. 0 if failed</td><td></td><td>
void *sp must be allocated at least 12 bytes behind it. If void *sp is 0, it will use the sp from the caller</td></tr>
</table></div><div id="gfx_ZeroVRAM"><h1>gfx_ZeroVRAM</h1>	<h3>syscall Adress 022674</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>clears VRAM with null bytes</td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="th_KillThread"><h1>th_KillThread</h1>	<h3>syscall Adress 022678</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Kill a thread by ID.</td><td>uint8_t th_KillThread(uint8_t id);</td><td>thread ID killed if successful, 0 if failed.</td><td></td><td>
Cannot kill thread ID 0.</td></tr>
</table></div><div id="fs_GetFilePtr"><h1>fs_GetFilePtr</h1>	<h3>syscall Adress 02267C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>get a pointer to a file's data section</td><td>void *fs_GetFilePtr(const char *path);</td><td>HL = file data pointer, BC = file data length, A = file flags, Cf set and HL = -1 if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_GetFDPtr"><h1>fs_GetFDPtr</h1>	<h3>syscall Adress 022680</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Return pointer to file data given a file descriptor</td><td>void *fs_GetFDPtr(void *fd);</td><td>pointer to file data, or -1 and Cf set if file data has not been allocated yet.</td><td></td><td>
</td></tr>
</table></div><div id="fs_GetFDLen"><h1>fs_GetFDLen</h1>	<h3>syscall Adress 022684</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Return length of file data given a file descriptor</td><td>int fs_GetFDLen(void *fd);</td><td>length of file data. Will be 0 if data has not been initizlized yet.</td><td></td><td>
</td></tr>
</table></div><div id="fs_ArcUnarcFD"><h1>fs_ArcUnarcFD</h1>	<h3>syscall Adress 022688</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="util_Zx0Decompress"><h1>util_Zx0Decompress</h1>	<h3>syscall Adress 02268C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_WaitKeyUnpress"><h1>sys_WaitKeyUnpress</h1>	<h3>syscall Adress 022690</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Wait until no keys are pressed.</td><td>None</td><td>None</td><td></td><td>
</td></tr>
</table></div><div id="sys_MallocDupStr"><h1>sys_MallocDupStr</h1>	<h3>syscall Adress 022694</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Malloc a copy of a string.</td><td>char *sys_MallocDupStr(const char *str);</td><td>Malloc'd copy and Cf unset or zero and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="sys_MallocDupStrN"><h1>sys_MallocDupStrN</h1>	<h3>syscall Adress 022698</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Malloc a copy of a string up to N characters.</td><td>char *sys_MallocDupStrN(const char *str, size_t len);</td><td>Malloc'd copy and Cf unset or zero and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="_SearchSymTable"><h1>_SearchSymTable</h1>	<h3>syscall Adress 02269C</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Search the symbol table (VAT) for a file specified in OP1</td><td>Same as ti.ChkFindSym, except that 0xFF is treated as a wildcard.</td><td>Same as ti.ChkFindSym.</td><td></td><td>
</td></tr>
</table></div><div id="fs_Rename"><h1>fs_Rename</h1>	<h3>syscall Adress 0226A0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>rename a file</td><td>void *fs_Rename(const char *old_name, const char *new_name);</td><td>file descriptor. returns zero if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_AllocChk"><h1>fs_AllocChk</h1>	<h3>syscall Adress 0226A4</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Check if a memory block can be allocated in flash</td><td>unsigned int fs_AllocChk(unsigned int len);</td><td>hl = first sector that would be allocated, or -1 and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="sys_GetExecType"><h1>sys_GetExecType</h1>	<h3>syscall Adress 0226A8</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Check the executable type of a given file</td><td>const char *sys_GetExecType(const char *path);</td><td>pointer to executable magic bytes, or -1 and Cf set if failed.</td><td></td><td>
returns pointer to executable code in de and length of executable code in bc if hl != -1</td></tr>
</table></div><div id="sys_GetExecTypeFD"><h1>sys_GetExecTypeFD</h1>	<h3>syscall Adress 0226AC</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Check the executable type of a given file descriptor</td><td>const char *sys_GetExecType(void *fd);</td><td>pointer to executable magic bytes, or -1 and Cf set if failed.</td><td></td><td>
</td></tr>
</table></div><div id="util_Zx7Compress"><h1>util_Zx7Compress</h1>	<h3>syscall Adress 0226B0</h3>
<table><th>What it does</th><th>Inputs</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td>Zx7 compress a block of memory.</td><td>int util_Zx7Compress(void *dest, void *src, int len, void (*progress_callback)(int src_offset));</td><td>length in bytes written to dest.</td><td></td><td>
</td></tr>
</table></div></body></html>